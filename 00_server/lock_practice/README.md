# 락을 구현해보자

## 락은 무엇인가요
멀티스레드/고루틴 혹은 여러 프로세스/서버가 같은 자원에 동시에 접근할 때,  
원하지 않는 상태 변화가 일어나지 않도록 순서를 강제로 정해 주는 도구입니다. 

즉, **공유 자원을 한 번에 한 명만 안전하게 접근하도록 접근을 제어하는 매커니즘** 입니다. 

### 공유 자원 
- 재고 수량
- 특정 사용자의 포인트 잔액
- 같은 DB row, 같은 파일

등 여러 스레드/프로세스/고루틴이 동시에 읽고 쓰면 경쟁 상태가 발생할 수 있는 대상을 말합니다. 

### 임계 영역
공유 자원에 접근하는 코드 구간 중 

**경쟁이 나면 안 되는 구간**을 임계 영역이라고 표현합니다.

```go
stock, _ := repo.FindByID(id)
stock.Quantity --
repo.Save(stock)
```
위의 세 줄 전체가 "같이 움직여야 하는 하나의 단위"이기 때문에, 여기에 락이 없으면,

1. Quantity 가 10 일 때 2개의 실행 단위가 동시에 접근
2. 각각 9,8 로 순차적 감소를 의도 했지만
3. 두 실행 단위가 동일하게 Quantity = 10을 받아 `10-1 = 9` 를 저장하는 경쟁 상태가 발생할 수 있습니다.

그렇기에 락은 
- 들어가기 전에 락을 잡고
- 끝나면 락을 풀어주는  
형태로 적용됩니다. 

## 락의 종류

이번 구현에서 사용한 락은 크게 아래의 다섯가지 입니다.  
각각의 특징과 구현 방법을 정리하는 것을 목적으로 합니다.

### 뮤텍스 락 (in-memory Mutex / synchronized)
단일 프로세스 안에서 사용하는 메모리 기반 락입니다.

`Go`에서는 `sync.Mutex`를, `Java`에서는 `synchronized` 블록이 대표적입니다.  
메모리 레벨에서 동작하기에 매우 빠르고 가볍습니다. 

하지만, 스코프 레벨이 프로세스 단위기 때문에 멀티 인스턴스, 멀티 서버에서는 사용이 불가능합니다.  
단일 인스턴스 환경에서 간단한 동작을 구현할 때 의미를 가질 수 있습니다.

### 낙관적 락 (Optimistic Lock)
동시에 변경되는 경우가 자주 없을 것이라 가정하고  
충돌이 실제로 발생했을 때만 실패/재처리 하는 방식입니다.

보통 버전 필드나 업데이트된 시간을 이용해서 구현합니다.  
`SELECT ... WHERE id = ?`로 읽을 때 현재 버전/업데이트 시간 도 함께 읽고,  
`UPDATE ... WHERE id = ? AND version = ?` 로 업데이트 해서 영향받은 row가 0인 경우 중간에 누가 먼저 업데이트 했다는 뜻으로 간주합니다.

해당 방식은 실제로 락을 걸지 않아 동시성이 높으나, 쓰기가 잦은 패턴에서는 충돌 시 재시도 로직으로 인해 추가적인 오버헤드가 발생합니다.

---

### 비관적 락 (Pessimistic Lock)
동시에 변경될 가능성이 높다고 가정하고  
처음부터 락을 걸고 시작하는 방식입니다. 

대표적으로 `SELECT ... FOR UPDATE` 를 사용하는 패턴이 여기에 속합니다.  
한 번 락을 잡으면, 다른 트랜잭션은 대기해야 하기에 충돌은 줄지만, 대기 시간이 길어질 수 있습니다. 

트랜잭션이 길게 끌리는 경우, 데드락이나 성능 문제의 위험이 커질 수 있습니다. 
정합성이 절대 깨지면 안되는 영역이나, 동시 업데이트가 매우 자주 발생하는 영역에서 사용을 고려할 수 있습니다. 

---

### 네임드 락

MySQL 에서는 `get_lock` 을 통해 커넥션 락을 제공하고,  
Postgres 에서는 `pg_advisory_xact_lock`을 통해 트랜잭션 락과, `pg_advisory_lock` 을 통해 커넥션 락을 제공합니다.  

DB 레벨에서 관리되므로, 여러 애플리케이션 인스턴스 간에도 유효하고,  
테이블이나 특정 row에 직접 락을 거는 방식이 아니라, 사전에 약속한 '키' 에 대해 락을 거는 형태이므로  
같은 "이름"을 공유하는 작업만 직렬화하고, 일반적인 `SELECT` 쿼리는 그대로 병렬로 처리할 수 있어, 읽기 작업의 동시성은 최대한 유지할 수 있습니다. 

---

### 분산 락

위에서 다룬 락들은 기본적으로 **단일 프로세스 또는 단일 DB 인스턴스**를 전제로 합니다.  
하지만 서버 인스턴스가 여러 대이거나, 분산 환경에서 여러 애플리케이션이 같은 자원을 공유하는 경우에는  
프로세스 내부 락이나 단일 DB 락만으로는 충분하지 않습니다.

이럴 때는 `Redis` 같은 **외부 스토리지 기반의 분산 락**을 사용할 수 있습니다.

Redis를 이용한 분산 락 방식으로는 대표적으로,

- `SETNX`(SET if Not eXists)와 만료 시간(TTL)을 조합해 **스핀 락**을 구현하는 방식
- PUB/SUB 또는 스트림(Streams) 구조를 이용해 요청을 **작업 큐 형태로 직렬화**하는 방식

등이 있습니다.

이런 분산 락은

여러 서버 인스턴스에서 동시에 접근하는 경우에도 특정 키에 대해서는

하나의 “전역 잠금 장치”로 동작하도록 만들어 주는 역할을 합니다.
